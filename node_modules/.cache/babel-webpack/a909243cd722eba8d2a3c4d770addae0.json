{"ast":null,"code":"import { NgZone, Injectable, NgModule } from '@angular/core';\nimport { Store, Action, Selector, State, NgxsModule } from '@ngxs/store';\nimport { __decorate, __metadata } from 'tslib';\nimport { NavigationStart, RoutesRecognized, ResolveEnd, NavigationCancel, NavigationError, NavigationEnd, Router, UrlSerializer } from '@angular/router';\nimport { LocationStrategy, Location } from '@angular/common';\nimport { isAngularInTestMode } from '@ngxs/store/internals';\nimport { first } from 'rxjs/operators';\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Public event api of the router\r\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@ngxs/store';\nimport * as ɵngcc2 from '@angular/router';\nimport * as ɵngcc3 from '@angular/common';\n\nclass Navigate {\n  /**\r\n   * @param {?} path\r\n   * @param {?=} queryParams\r\n   * @param {?=} extras\r\n   */\n  constructor(path, queryParams, extras) {\n    this.path = path;\n    this.queryParams = queryParams;\n    this.extras = extras;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] Navigate';\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  Navigate.prototype.path;\n  /** @type {?} */\n\n  Navigate.prototype.queryParams;\n  /** @type {?} */\n\n  Navigate.prototype.extras;\n}\n/**\r\n *\r\n * Angular Routers internal state events\r\n *\r\n */\n\n/**\r\n * An action dispatched when the router navigates.\r\n * @template T\r\n */\n\n\nclass RouterNavigation {\n  /**\r\n   * @param {?} routerState\r\n   * @param {?} event\r\n   * @param {?=} trigger\r\n   */\n  constructor(routerState, event, trigger = 'none') {\n    this.routerState = routerState;\n    this.event = event;\n    this.trigger = trigger;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterNavigation';\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  RouterNavigation.prototype.routerState;\n  /** @type {?} */\n\n  RouterNavigation.prototype.event;\n  /** @type {?} */\n\n  RouterNavigation.prototype.trigger;\n}\n/**\r\n * An action dispatched when the router cancel navigation.\r\n * @template T, V\r\n */\n\n\nclass RouterCancel {\n  /**\r\n   * @param {?} routerState\r\n   * @param {?} storeState\r\n   * @param {?} event\r\n   * @param {?=} trigger\r\n   */\n  constructor(routerState, storeState, event, trigger = 'none') {\n    this.routerState = routerState;\n    this.storeState = storeState;\n    this.event = event;\n    this.trigger = trigger;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterCancel';\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  RouterCancel.prototype.routerState;\n  /** @type {?} */\n\n  RouterCancel.prototype.storeState;\n  /** @type {?} */\n\n  RouterCancel.prototype.event;\n  /** @type {?} */\n\n  RouterCancel.prototype.trigger;\n}\n/**\r\n * An action dispatched when the router errors.\r\n * @template T, V\r\n */\n\n\nclass RouterError {\n  /**\r\n   * @param {?} routerState\r\n   * @param {?} storeState\r\n   * @param {?} event\r\n   * @param {?=} trigger\r\n   */\n  constructor(routerState, storeState, event, trigger = 'none') {\n    this.routerState = routerState;\n    this.storeState = storeState;\n    this.event = event;\n    this.trigger = trigger;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterError';\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  RouterError.prototype.routerState;\n  /** @type {?} */\n\n  RouterError.prototype.storeState;\n  /** @type {?} */\n\n  RouterError.prototype.event;\n  /** @type {?} */\n\n  RouterError.prototype.trigger;\n}\n/**\r\n * An action dispatched when the `ResolveEnd` event is triggered.\r\n * @template T\r\n */\n\n\nclass RouterDataResolved {\n  /**\r\n   * @param {?} routerState\r\n   * @param {?} event\r\n   * @param {?=} trigger\r\n   */\n  constructor(routerState, event, trigger = 'none') {\n    this.routerState = routerState;\n    this.event = event;\n    this.trigger = trigger;\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterDataResolved';\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  RouterDataResolved.prototype.routerState;\n  /** @type {?} */\n\n  RouterDataResolved.prototype.event;\n  /** @type {?} */\n\n  RouterDataResolved.prototype.trigger;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @abstract\r\n * @template T\r\n */\n\n\nclass RouterStateSerializer {}\n\nif (false) {\n  /**\r\n   * @abstract\r\n   * @param {?} routerState\r\n   * @return {?}\r\n   */\n  RouterStateSerializer.prototype.serialize = function (routerState) {};\n}\n/**\r\n * @record\r\n */\n\n\nfunction SerializedRouterStateSnapshot() {}\n\nif (false) {\n  /** @type {?} */\n  SerializedRouterStateSnapshot.prototype.root;\n  /** @type {?} */\n\n  SerializedRouterStateSnapshot.prototype.url;\n}\n\nclass DefaultRouterStateSerializer {\n  /**\r\n   * @param {?} routerState\r\n   * @return {?}\r\n   */\n  serialize(routerState) {\n    return {\n      root: this.serializeRoute(routerState.root),\n      url: routerState.url\n    };\n  }\n  /**\r\n   * @private\r\n   * @param {?} route\r\n   * @return {?}\r\n   */\n\n\n  serializeRoute(route) {\n    /** @type {?} */\n    const children = route.children.map(\n    /**\r\n    * @param {?} c\r\n    * @return {?}\r\n    */\n    c => this.serializeRoute(c));\n    return {\n      url: route.url,\n      params: route.params,\n      queryParams: route.queryParams,\n      fragment: route.fragment,\n      data: route.data,\n      outlet: route.outlet,\n      component: null,\n      routeConfig: null,\n      root:\n      /** @type {?} */\n      null,\n      parent: null,\n      firstChild: children[0],\n      children: children,\n      pathFromRoot:\n      /** @type {?} */\n      null,\n      paramMap: route.paramMap,\n      queryParamMap: route.queryParamMap,\n      toString: route.toString\n    };\n  }\n\n}\n\nvar RouterState_1;\n/**\r\n * @record\r\n * @template T\r\n */\n\nfunction RouterStateModel() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  RouterStateModel.prototype.state;\n  /** @type {?|undefined} */\n\n  RouterStateModel.prototype.navigationId;\n  /** @type {?} */\n\n  RouterStateModel.prototype.trigger;\n}\n\nlet RouterState = RouterState_1 = class RouterState {\n  /**\r\n   * @param {?} _store\r\n   * @param {?} _router\r\n   * @param {?} _serializer\r\n   * @param {?} _ngZone\r\n   * @param {?} _urlSerializer\r\n   * @param {?} _locationStrategy\r\n   * @param {?} _location\r\n   */\n  constructor(_store, _router, _serializer, _ngZone, _urlSerializer, _locationStrategy, _location) {\n    this._store = _store;\n    this._router = _router;\n    this._serializer = _serializer;\n    this._ngZone = _ngZone;\n    this._urlSerializer = _urlSerializer;\n    this._locationStrategy = _locationStrategy;\n    this._location = _location;\n    /**\r\n     * Determines how navigation was performed by the `RouterState` itself\r\n     * or outside via `new Navigate(...)`\r\n     */\n\n    this._trigger = 'none';\n    /**\r\n     * That's the serialized state from the `Router` class\r\n     */\n\n    this._routerState = null;\n    /**\r\n     * That's the value of the `RouterState` state\r\n     */\n\n    this._storeState = null;\n    this._lastRoutesRecognized =\n    /** @type {?} */\n    null;\n    this.setUpStoreListener();\n    this.setUpRouterEventsListener();\n    this.checkInitialNavigationOnce();\n  }\n  /**\r\n   * @template T\r\n   * @param {?} state\r\n   * @return {?}\r\n   */\n\n\n  static state(state) {\n    return state && state.state;\n  }\n  /**\r\n   * @param {?} state\r\n   * @return {?}\r\n   */\n\n\n  static url(state) {\n    return state && state.state && state.state.url;\n  }\n  /**\r\n   * @param {?} _\r\n   * @param {?} action\r\n   * @return {?}\r\n   */\n\n\n  navigate(_, action) {\n    return this._ngZone.run(\n    /**\r\n    * @return {?}\r\n    */\n    () => this._router.navigate(action.path, Object.assign({\n      queryParams: action.queryParams\n    }, action.extras)));\n  }\n  /**\r\n   * @param {?} ctx\r\n   * @param {?} action\r\n   * @return {?}\r\n   */\n\n\n  angularRouterAction(ctx, action) {\n    ctx.setState(Object.assign({}, ctx.getState(), {\n      trigger: action.trigger,\n      state: action.routerState,\n      navigationId: action.event.id\n    }));\n  }\n  /**\r\n   * @private\r\n   * @return {?}\r\n   */\n\n\n  setUpStoreListener() {\n    this._store.select(RouterState_1).subscribe(\n    /**\r\n    * @param {?} state\r\n    * @return {?}\r\n    */\n    state => {\n      this.navigateIfNeeded(state);\n    });\n  }\n  /**\r\n   * @private\r\n   * @return {?}\r\n   */\n\n\n  setUpRouterEventsListener() {\n    this._router.events.subscribe(\n    /**\r\n    * @param {?} event\r\n    * @return {?}\r\n    */\n    event => {\n      if (event instanceof NavigationStart) {\n        this.navigationStart();\n      } else if (event instanceof RoutesRecognized) {\n        this._lastRoutesRecognized = event;\n      } else if (event instanceof ResolveEnd) {\n        this.dispatchRouterDataResolved(event);\n      } else if (event instanceof NavigationCancel) {\n        this.dispatchRouterCancel(event);\n        this.reset();\n      } else if (event instanceof NavigationError) {\n        this.dispatchRouterError(event);\n        this.reset();\n      } else if (event instanceof NavigationEnd) {\n        this.navigationEnd();\n        this.reset();\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   * @return {?}\r\n   */\n\n\n  navigationStart() {\n    this._routerState = this._serializer.serialize(this._router.routerState.snapshot);\n\n    if (this._trigger !== 'none') {\n      this._storeState = this._store.selectSnapshot(RouterState_1);\n    }\n  }\n  /**\r\n   * @private\r\n   * @return {?}\r\n   */\n\n\n  navigationEnd() {\n    if (this.shouldDispatchRouterNavigation()) {\n      this.dispatchRouterNavigation();\n    }\n  }\n  /**\r\n   * @private\r\n   * @return {?}\r\n   */\n\n\n  shouldDispatchRouterNavigation() {\n    if (!this._storeState) return true;\n    return this._trigger !== 'store';\n  }\n  /**\r\n   * @private\r\n   * @param {?} state\r\n   * @return {?}\r\n   */\n\n\n  navigateIfNeeded(state) {\n    /** @type {?} */\n    const canSkipNavigation = !this._storeState || !this._storeState.state || !state || state.trigger === 'router' || this._router.url === this._storeState.state.url;\n\n    if (canSkipNavigation) {\n      return;\n    }\n\n    this._trigger = 'store';\n\n    this._ngZone.run(\n    /**\r\n    * @return {?}\r\n    */\n    () => {\n      this._router.navigateByUrl(\n      /** @type {?} */\n\n      /** @type {?} */\n      this._storeState.state.url);\n    });\n  }\n  /**\r\n   * @private\r\n   * @return {?}\r\n   */\n\n\n  dispatchRouterNavigation() {\n    /** @type {?} */\n    const nextRouterState = this._serializer.serialize(this._lastRoutesRecognized.state);\n\n    this.dispatchRouterAction(new RouterNavigation(nextRouterState, new RoutesRecognized(this._lastRoutesRecognized.id, this._lastRoutesRecognized.url, this._lastRoutesRecognized.urlAfterRedirects, nextRouterState), this._trigger));\n  }\n  /**\r\n   * @private\r\n   * @param {?} event\r\n   * @return {?}\r\n   */\n\n\n  dispatchRouterCancel(event) {\n    this.dispatchRouterAction(new RouterCancel(\n    /** @type {?} */\n    this._routerState, this._storeState, event, this._trigger));\n  }\n  /**\r\n   * @private\r\n   * @param {?} event\r\n   * @return {?}\r\n   */\n\n\n  dispatchRouterError(event) {\n    this.dispatchRouterAction(new RouterError(\n    /** @type {?} */\n    this._routerState, this._storeState, new NavigationError(event.id, event.url, `${event}`), this._trigger));\n  }\n  /**\r\n   * @private\r\n   * @template T\r\n   * @param {?} action\r\n   * @return {?}\r\n   */\n\n\n  dispatchRouterAction(action) {\n    this._trigger = 'router';\n\n    try {\n      this._store.dispatch(action);\n    } finally {\n      this._trigger = 'none';\n    }\n  }\n  /**\r\n   * @private\r\n   * @param {?} event\r\n   * @return {?}\r\n   */\n\n\n  dispatchRouterDataResolved(event) {\n    /** @type {?} */\n    const routerState = this._serializer.serialize(event.state);\n\n    this.dispatchRouterAction(new RouterDataResolved(routerState, event, this._trigger));\n  }\n  /**\r\n   * @private\r\n   * @return {?}\r\n   */\n\n\n  reset() {\n    this._trigger = 'none';\n    this._storeState = null;\n    this._routerState = null;\n  }\n  /**\r\n   * No sense to mess up the `setUpRouterEventsListener` method as we have\r\n   * to perform this check only once and unsubscribe after the first event\r\n   * is triggered\r\n   * @private\r\n   * @return {?}\r\n   */\n\n\n  checkInitialNavigationOnce() {\n    if (isAngularInTestMode()) {\n      return;\n    }\n\n    this._router.events.pipe(first(\n    /**\r\n    * @param {?} event\r\n    * @return {?}\r\n    */\n    event => event instanceof RoutesRecognized)).subscribe(\n    /**\r\n    * @param {?} __0\r\n    * @return {?}\r\n    */\n    ({\n      url\n    }) => {\n      // `location.pathname` always equals manually entered URL in the address bar\n      // e.g. `location.pathname === '/foo'`, but the `router` state has been initialized\n      // with another URL (e.g. used in combination with `NgxsStoragePlugin`), thus the\n      // `RouterNavigation` action will be dispatched and the user will be redirected to the\n      // previously saved URL. We want to prevent such behavior, so we perform this check\n      // `location.pathname` always equals manually entered URL in the address bar\n      // e.g. `location.pathname === '/foo'`, but the `router` state has been initialized\n      // with another URL (e.g. used in combination with `NgxsStoragePlugin`), thus the\n      // `RouterNavigation` action will be dispatched and the user will be redirected to the\n      // previously saved URL. We want to prevent such behavior, so we perform this check\n      // `url` is a recognized URL by the Angular's router, while `currentUrl` is an actual URL\n      // entered in the browser's address bar\n      // `PathLocationStrategy.prototype.path()` returns a concatenation of\n      // `PlatformLocation.pathname` and normalized `PlatformLocation.search`.\n      // `Location.prototype.normalize` strips base href from the URL,\n      // if `baseHref` (declared in angular.json) for example is `/en`\n      // and the URL is `/test#anchor` - then `_locationStrategy.path(true)` will return `/en/test#anchor`,\n      // but `/en/test#anchor` is not known to the Angular's router, so we have to strip `/en`\n      // from the URL\n\n      /** @type {?} */\n      const currentUrl = this._location.normalize(this._locationStrategy.path(true));\n      /** @type {?} */\n\n\n      const currentUrlTree = this._urlSerializer.parse(currentUrl); // We need to serialize the URL because in that example `/test/?redirect=https://google.com/`\n      // Angular will recognize it as `/test?redirect=https:%2F%2Fwww.google.com%2F`\n      // so we have to run the `currentUrl` via the `UrlSerializer` that will encode characters\n\n      /** @type {?} */\n\n\n      const currentSerializedUrl = this._urlSerializer.serialize(currentUrlTree); // If URLs differ from each other - we've got to perform a redirect to the manually entered URL\n      // in the address bar, as it must have a priority\n\n\n      if (currentSerializedUrl !== url) {\n        this._router.navigateByUrl(currentUrl);\n      }\n    });\n  }\n\n};\n\nRouterState.ɵfac = function RouterState_Factory(t) {\n  return new (t || RouterState)(ɵngcc0.ɵɵinject(ɵngcc1.Store), ɵngcc0.ɵɵinject(ɵngcc2.Router), ɵngcc0.ɵɵinject(RouterStateSerializer), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc2.UrlSerializer), ɵngcc0.ɵɵinject(ɵngcc3.LocationStrategy), ɵngcc0.ɵɵinject(ɵngcc3.Location));\n};\n\nRouterState.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: RouterState,\n  factory: function (t) {\n    return RouterState.ɵfac(t);\n  }\n});\n\nRouterState.ctorParameters = () => [{\n  type: Store\n}, {\n  type: Router\n}, {\n  type: RouterStateSerializer\n}, {\n  type: NgZone\n}, {\n  type: UrlSerializer\n}, {\n  type: LocationStrategy\n}, {\n  type: Location\n}];\n/** @nocollapse */\n\n\nRouterState.ctorParameters = () => [{\n  type: Store\n}, {\n  type: Router\n}, {\n  type: RouterStateSerializer\n}, {\n  type: NgZone\n}, {\n  type: UrlSerializer\n}, {\n  type: LocationStrategy\n}, {\n  type: Location\n}];\n\n__decorate([Action(Navigate), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, Navigate]), __metadata(\"design:returntype\", void 0)], RouterState.prototype, \"navigate\", null);\n\n__decorate([Action([RouterNavigation, RouterError, RouterCancel, RouterDataResolved]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, Object]), __metadata(\"design:returntype\", void 0)], RouterState.prototype, \"angularRouterAction\", null);\n\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], RouterState, \"state\", null);\n\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Object)], RouterState, \"url\", null);\n\nRouterState = RouterState_1 = __decorate([State({\n  name: 'router',\n  defaults: {\n    state: undefined,\n    navigationId: undefined,\n    trigger: 'none'\n  }\n}), __metadata(\"design:paramtypes\", [Store, Router, RouterStateSerializer, NgZone, UrlSerializer, LocationStrategy, Location])], RouterState);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * Determines how navigation was performed by the `RouterState` itself\r\n   * or outside via `new Navigate(...)`\r\n   * @type {?}\r\n   * @private\r\n   */\n  RouterState.prototype._trigger;\n  /**\r\n   * That's the serialized state from the `Router` class\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  RouterState.prototype._routerState;\n  /**\r\n   * That's the value of the `RouterState` state\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  RouterState.prototype._storeState;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  RouterState.prototype._lastRoutesRecognized;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  RouterState.prototype._store;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  RouterState.prototype._router;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  RouterState.prototype._serializer;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  RouterState.prototype._ngZone;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  RouterState.prototype._urlSerializer;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  RouterState.prototype._locationStrategy;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  RouterState.prototype._location;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nlet NgxsRouterPluginModule = /*#__PURE__*/(() => {\n  class NgxsRouterPluginModule {\n    /**\r\n     * @return {?}\r\n     */\n    static forRoot() {\n      return {\n        ngModule: NgxsRouterPluginModule,\n        providers: [{\n          provide: RouterStateSerializer,\n          useClass: DefaultRouterStateSerializer\n        }]\n      };\n    }\n\n  }\n\n  NgxsRouterPluginModule.ɵfac = function NgxsRouterPluginModule_Factory(t) {\n    return new (t || NgxsRouterPluginModule)();\n  };\n\n  NgxsRouterPluginModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxsRouterPluginModule\n  });\n  NgxsRouterPluginModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[NgxsModule.forFeature([RouterState])]]\n  });\n  return NgxsRouterPluginModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxsRouterPluginModule, {\n    imports: [ɵngcc1.ɵbc]\n  });\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nexport { DefaultRouterStateSerializer, Navigate, NgxsRouterPluginModule, RouterCancel, RouterDataResolved, RouterError, RouterNavigation, RouterState, RouterStateSerializer }; //# sourceMappingURL=ngxs-router-plugin.js.map","map":null,"metadata":{},"sourceType":"module"}