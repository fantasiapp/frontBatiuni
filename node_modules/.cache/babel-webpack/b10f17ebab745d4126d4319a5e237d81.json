{"ast":null,"code":"import _asyncToGenerator from \"/Users/jlw/Documents/frontBatiuni/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { EventEmitter } from \"@angular/core\";\nimport { Subject } from \"rxjs\";\nimport * as i0 from \"@angular/core\";\nexport let Destroy$ = /*#__PURE__*/(() => {\n  class Destroy$ {\n    constructor() {\n      this.destroy$ = new Subject();\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n  }\n\n  Destroy$.ɵfac = function Destroy$_Factory(t) {\n    return new (t || Destroy$)();\n  };\n\n  Destroy$.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: Destroy$\n  });\n  return Destroy$;\n})();\nexport let IndexBased = /*#__PURE__*/(() => {\n  class IndexBased {\n    constructor() {\n      this._index = 0;\n      this.indexChange = new EventEmitter();\n    }\n\n    get index() {\n      return this._index;\n    }\n\n    set index(value) {\n      if (this._index == value) return;\n      this.indexChanged(value - this.index); //will set the index\n\n      this.indexChange.emit(this.index);\n    }\n\n    get first() {\n      return this._index == 0;\n    }\n\n  }\n\n  IndexBased.ɵfac = function IndexBased_Factory(t) {\n    return new (t || IndexBased)();\n  };\n\n  IndexBased.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: IndexBased,\n    inputs: {\n      index: \"index\"\n    },\n    outputs: {\n      indexChange: \"indexChange\"\n    }\n  });\n  return IndexBased;\n})();\n;\nexport let AnimateCSS = /*#__PURE__*/(() => {\n  class AnimateCSS extends IndexBased {\n    constructor(factoryResolver, view) {\n      super();\n      this.factoryResolver = factoryResolver;\n      this.view = view;\n    }\n\n    create(what, type, ctx = {}) {\n      return type == 'component' ? this.createComponent(what) : this.createTemplate(what, ctx);\n    }\n\n    createTemplate(template, ctx = {}) {\n      let view = this.view.createEmbeddedView(template, ctx);\n      return {\n        element: view.rootNodes[0],\n        view\n      };\n    }\n\n    createComponent(component) {\n      let factory = this.factoryResolver.resolveComponentFactory(component),\n          componentRef = this.view.createComponent(factory);\n      return {\n        element: componentRef.location.nativeElement,\n        view: componentRef.hostView\n      };\n    }\n\n    animateWithClass(element, className, callback) {\n      var _a;\n\n      if (element.parentElement) element.parentElement.scrollTop = 0;\n      element.scrollTop = 0;\n      (_a = element.classList) === null || _a === void 0 ? void 0 : _a.add(className);\n      let save = element.onanimationend;\n\n      element.onanimationend = e => {\n        save && save.call(element, e);\n        element.onanimationend = save;\n        callback === null || callback === void 0 ? void 0 : callback(element, e);\n        element.classList.remove(className);\n      };\n    }\n\n  }\n\n  AnimateCSS.ɵfac = function AnimateCSS_Factory(t) {\n    return new (t || AnimateCSS)(i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n\n  AnimateCSS.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: AnimateCSS,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return AnimateCSS;\n})();\n;\nexport let UIOpenMenu = /*#__PURE__*/(() => {\n  class UIOpenMenu {\n    constructor() {\n      this.initialized = false;\n      this._open = false;\n      this.block = true;\n      this.openChange = new EventEmitter();\n    }\n\n    get open() {\n      return this._open;\n    }\n\n    set open(value) {\n      if (!this.initialized) {\n        this.initialized = true;\n        this._open = value;\n        return;\n      }\n\n      if (value == this._open) return;\n\n      if (value) {\n        if (this.block) document.body.classList.add('blocked');\n        this._open = value;\n      } else {\n        if (this.block) document.body.classList.remove('blocked'); //this._open = false;\n\n        this.close();\n      }\n    }\n\n  }\n\n  UIOpenMenu.ɵfac = function UIOpenMenu_Factory(t) {\n    return new (t || UIOpenMenu)();\n  };\n\n  UIOpenMenu.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: UIOpenMenu,\n    hostVars: 2,\n    hostBindings: function UIOpenMenu_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"open\", ctx._open);\n      }\n    },\n    inputs: {\n      block: \"block\",\n      open: \"open\"\n    },\n    outputs: {\n      openChange: \"openChange\"\n    }\n  });\n  return UIOpenMenu;\n})();\n;\nexport let DimensionMenu = /*#__PURE__*/(() => {\n  class DimensionMenu extends UIOpenMenu {\n    constructor() {\n      super();\n      this.dimension = {\n        left: '0',\n        top: '0'\n      };\n    }\n\n    get dimensionX() {\n      return this.dimension.left;\n    }\n\n    get dimensionY() {\n      return this.dimension.top;\n    }\n\n    get width() {\n      return this.dimension.width || '100%';\n    }\n\n    get height() {\n      return this.dimension.height || '100%';\n    }\n\n  }\n\n  DimensionMenu.ɵfac = function DimensionMenu_Factory(t) {\n    return new (t || DimensionMenu)();\n  };\n\n  DimensionMenu.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: DimensionMenu,\n    hostVars: 8,\n    hostBindings: function DimensionMenu_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"left\", ctx.dimensionX)(\"top\", ctx.dimensionY)(\"width\", ctx.width)(\"height\", ctx.height);\n      }\n    },\n    inputs: {\n      dimension: \"dimension\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return DimensionMenu;\n})();\n; //Very important class, should be fine for now\n//valueChange is trigged whenever the value changes\n//there should be another event for stuff that come from the DOM\n//because now we have to rely on other events like (click) etc to get user action\n//this won't cause issue but it will feel like dodging bullets once to start doing\n//something unorthodox\n\nexport let UIDefaultAccessor = /*#__PURE__*/(() => {\n  class UIDefaultAccessor {\n    constructor(cd) {\n      this.cd = cd;\n      this.valueChange = new EventEmitter();\n      this.isDisabled = false;\n\n      this.onTouched = () => {};\n\n      this.onChanged = value => {};\n    }\n\n    get value() {\n      return this._value;\n    }\n\n    set value(value) {\n      this.set(value);\n    }\n\n    get tabIndex() {\n      return 0;\n    }\n\n    $onTouched() {\n      this.onTouched();\n    }\n\n    set(next, notifyForm = true) {\n      if (next !== this.value) {\n        this.valueChange.emit(this._value = next);\n        if (notifyForm) this.onChanged(this.value);\n        this.cd.markForCheck();\n      } //apparently skipping this call breaks everything\n\n\n      this.$onTouched();\n    }\n\n    onChange(e) {\n      var _a;\n\n      if (this.isDisabled) {\n        (_a = e.preventDefault) === null || _a === void 0 ? void 0 : _a.call(e);\n        return;\n      }\n\n      this.set(this.getInput(e));\n      return this.value;\n    }\n\n    //default implementation\n    getInput(e) {\n      return e;\n    }\n\n    set disabled(disabled) {\n      if (disabled != null) this.isDisabled = true;else this.isDisabled = false;\n    }\n\n    setDisabledState(isDisabled) {\n      this.isDisabled = isDisabled;\n    }\n\n    registerOnTouched(onTouched) {\n      this.onTouched = onTouched;\n    }\n\n    writeValue(value) {\n      if (value === void 0) return;\n      this.set(value, false);\n    }\n\n    registerOnChange(onChanged) {\n      this.onChanged = onChanged;\n    }\n\n  }\n\n  UIDefaultAccessor.ɵfac = function UIDefaultAccessor_Factory(t) {\n    return new (t || UIDefaultAccessor)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  UIDefaultAccessor.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: UIDefaultAccessor,\n    hostVars: 1,\n    hostBindings: function UIDefaultAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"blur\", function UIDefaultAccessor_blur_HostBindingHandler() {\n          return ctx.$onTouched();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabIndex);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    }\n  });\n  return UIDefaultAccessor;\n})();\n;\nexport let UIAsyncAccessor = /*#__PURE__*/(() => {\n  class UIAsyncAccessor extends UIDefaultAccessor {\n    constructor(cd) {\n      super(cd);\n    }\n\n    getInput(e) {\n      return super.getInput(e);\n    }\n\n    onChange(e) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        var _a;\n\n        if (_this.isDisabled) {\n          (_a = e.preventDefault) === null || _a === void 0 ? void 0 : _a.call(e);\n          return;\n        }\n\n        let next = yield _this.getInput(e);\n\n        _this.set(next);\n      })();\n    }\n\n  }\n\n  UIAsyncAccessor.ɵfac = function UIAsyncAccessor_Factory(t) {\n    return new (t || UIAsyncAccessor)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  UIAsyncAccessor.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: UIAsyncAccessor,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return UIAsyncAccessor;\n})();\n; //make it compatible with references ??\n\nexport const PropertyTrap = {\n  get(target, property) {\n    const path = property.split('.');\n    let root = target;\n\n    for (const field of path) {\n      if (root[field]) root = root[field];else return undefined;\n    }\n\n    ;\n    return root;\n  },\n\n  set(target, property, value) {\n    const path = property.split('.'),\n          lastField = path[path.length - 1];\n    let root = target;\n\n    for (const field of path.slice(0, -1)) {\n      if (root[field]) root = root[field];else root = root[field] = {};\n    }\n\n    root[lastField] = value;\n    return true;\n  }\n\n};","map":null,"metadata":{},"sourceType":"module"}