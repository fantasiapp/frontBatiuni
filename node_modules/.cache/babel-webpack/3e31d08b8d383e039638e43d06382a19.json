{"ast":null,"code":"import { InjectionToken, Injectable, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { StateToken, actionMatcher, InitState, UpdateState, getValue, setValue, NGXS_PLUGINS } from '@ngxs/store';\nimport { isPlatformServer } from '@angular/common';\nimport { tap } from 'rxjs/operators';\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @enum {number} */\n\nimport * as ɵngcc0 from '@angular/core';\nconst StorageOption = {\n  LocalStorage: 0,\n  SessionStorage: 1\n};\n/**\r\n * @record\r\n */\n\nfunction NgxsStoragePluginOptions() {}\n\nif (false) {\n  /**\r\n   * Key for the state slice to store in the storage engine.\r\n   * @type {?|undefined}\r\n   */\n  NgxsStoragePluginOptions.prototype.key;\n  /**\r\n   * Storage engine to use. Deaults to localStorage but can provide\r\n   *\r\n   * sessionStorage or custom implementation of the StorageEngine interface\r\n   * @type {?|undefined}\r\n   */\n\n  NgxsStoragePluginOptions.prototype.storage;\n  /**\r\n   * Migration strategies.\r\n   * @type {?|undefined}\r\n   */\n\n  NgxsStoragePluginOptions.prototype.migrations;\n  /**\r\n   * Serailizer for the object before its pushed into the engine.\r\n   * @param {?} obj\r\n   * @return {?}\r\n   */\n\n  NgxsStoragePluginOptions.prototype.serialize = function (obj) {};\n  /**\r\n   * Deserializer for the object before its pulled out of the engine.\r\n   * @param {?} obj\r\n   * @return {?}\r\n   */\n\n\n  NgxsStoragePluginOptions.prototype.deserialize = function (obj) {};\n  /**\r\n   * Method to alter object before serialization.\r\n   * @param {?} obj\r\n   * @param {?} key\r\n   * @return {?}\r\n   */\n\n\n  NgxsStoragePluginOptions.prototype.beforeSerialize = function (obj, key) {};\n  /**\r\n   * Method to alter object after deserialization.\r\n   * @param {?} obj\r\n   * @param {?} key\r\n   * @return {?}\r\n   */\n\n\n  NgxsStoragePluginOptions.prototype.afterDeserialize = function (obj, key) {};\n}\n/** @type {?} */\n\n\nconst NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken('NGXS_STORAGE_PLUGIN_OPTION');\n/** @type {?} */\n\nconst STORAGE_ENGINE = new InjectionToken('STORAGE_ENGINE');\n/**\r\n * @record\r\n */\n\nfunction StorageEngine() {}\n\nif (false) {\n  /** @type {?} */\n  StorageEngine.prototype.length;\n  /**\r\n   * @param {?} key\r\n   * @return {?}\r\n   */\n\n  StorageEngine.prototype.getItem = function (key) {};\n  /**\r\n   * @param {?} key\r\n   * @param {?} val\r\n   * @return {?}\r\n   */\n\n\n  StorageEngine.prototype.setItem = function (key, val) {};\n  /**\r\n   * @param {?} key\r\n   * @return {?}\r\n   */\n\n\n  StorageEngine.prototype.removeItem = function (key) {};\n  /**\r\n   * @return {?}\r\n   */\n\n\n  StorageEngine.prototype.clear = function () {};\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * If the `key` option is not provided then the below constant\r\n * will be used as a default key\r\n * @type {?}\r\n */\n\n\nconst DEFAULT_STATE_KEY = '@@STATE';\n/**\r\n * This key is used to retrieve static metadatas on state classes.\r\n * This constant is taken from the core codebase\r\n * @type {?}\r\n */\n\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\n/**\r\n * @param {?} key\r\n * @return {?}\r\n */\n\nfunction transformKeyOption(key) {\n  if (!Array.isArray(key)) {\n    key = [key];\n  }\n\n  return key.map(\n  /**\r\n  * @param {?} token\r\n  * @return {?}\r\n  */\n  token => {\n    // If it has the `NGXS_OPTIONS_META` key then it means the developer\n    // has provided state class like `key: [AuthState]`.\n    if (token.hasOwnProperty(META_OPTIONS_KEY)) {\n      // The `name` property will be an actual state name or a `StateToken`.\n      token =\n      /** @type {?} */\n      token[META_OPTIONS_KEY].name;\n    }\n\n    return token instanceof StateToken ? token.getName() :\n    /** @type {?} */\n    token;\n  });\n}\n/**\r\n * @param {?} options\r\n * @return {?}\r\n */\n\n\nfunction storageOptionsFactory(options) {\n  if (options !== undefined && options.key) {\n    options.key = transformKeyOption(options.key);\n  }\n\n  return Object.assign({\n    key: [DEFAULT_STATE_KEY],\n    storage: 0\n    /* LocalStorage */\n    ,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    beforeSerialize:\n    /**\r\n    * @param {?} obj\r\n    * @return {?}\r\n    */\n    obj => obj,\n    afterDeserialize:\n    /**\r\n    * @param {?} obj\r\n    * @return {?}\r\n    */\n    obj => obj\n  }, options);\n}\n/**\r\n * @param {?} options\r\n * @param {?} platformId\r\n * @return {?}\r\n */\n\n\nfunction engineFactory(options, platformId) {\n  if (isPlatformServer(platformId)) {\n    return null;\n  }\n\n  if (options.storage === 0\n  /* LocalStorage */\n  ) {\n    return localStorage;\n  } else if (options.storage === 1\n  /* SessionStorage */\n  ) {\n    return sessionStorage;\n  }\n\n  return null;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nlet NgxsStoragePlugin = /*#__PURE__*/(() => {\n  class NgxsStoragePlugin {\n    /**\r\n     * @param {?} _options\r\n     * @param {?} _engine\r\n     * @param {?} _platformId\r\n     */\n    constructor(_options, _engine, _platformId) {\n      this._options = _options;\n      this._engine = _engine;\n      this._platformId = _platformId;\n    }\n    /**\r\n     * @param {?} state\r\n     * @param {?} event\r\n     * @param {?} next\r\n     * @return {?}\r\n     */\n\n\n    handle(state, event, next) {\n      if (isPlatformServer(this._platformId) && this._engine === null) {\n        return next(state, event);\n      } // We cast to `string[]` here as we're sure that this option has been\n      // transformed by the `storageOptionsFactory` function that provided token\n\n      /** @type {?} */\n\n\n      const keys =\n      /** @type {?} */\n      this._options.key;\n      /** @type {?} */\n\n      const matches = actionMatcher(event);\n      /** @type {?} */\n\n      const isInitAction = matches(InitState) || matches(UpdateState);\n      /** @type {?} */\n\n      let hasMigration = false;\n\n      if (isInitAction) {\n        for (const key of keys) {\n          /** @type {?} */\n          const isMaster = key === DEFAULT_STATE_KEY;\n          /** @type {?} */\n\n          let val = this._engine.getItem(\n          /** @type {?} */\n          key);\n\n          if (val !== 'undefined' && typeof val !== 'undefined' && val !== null) {\n            try {\n              /** @type {?} */\n              const newVal =\n              /** @type {?} */\n              this._options.deserialize(val);\n\n              val =\n              /** @type {?} */\n              this._options.afterDeserialize(newVal, key);\n            } catch (e) {\n              console.error('Error ocurred while deserializing the store value, falling back to empty object.');\n              val = {};\n            }\n\n            if (this._options.migrations) {\n              this._options.migrations.forEach(\n              /**\r\n              * @param {?} strategy\r\n              * @return {?}\r\n              */\n              strategy => {\n                /** @type {?} */\n                const versionMatch = strategy.version === getValue(val, strategy.versionKey || 'version');\n                /** @type {?} */\n\n                const keyMatch = !strategy.key && isMaster || strategy.key === key;\n\n                if (versionMatch && keyMatch) {\n                  val = strategy.migrate(val);\n                  hasMigration = true;\n                }\n              });\n            }\n\n            if (!isMaster) {\n              state = setValue(state,\n              /** @type {?} */\n              key, val);\n            } else {\n              state = Object.assign({}, state, val);\n            }\n          }\n        }\n      }\n\n      return next(state, event).pipe(tap(\n      /**\r\n      * @param {?} nextState\r\n      * @return {?}\r\n      */\n      nextState => {\n        if (!isInitAction || isInitAction && hasMigration) {\n          for (const key of keys) {\n            /** @type {?} */\n            let val = nextState;\n\n            if (key !== DEFAULT_STATE_KEY) {\n              val = getValue(nextState,\n              /** @type {?} */\n              key);\n            }\n\n            try {\n              /** @type {?} */\n              const newVal =\n              /** @type {?} */\n              this._options.beforeSerialize(val, key);\n\n              this._engine.setItem(\n              /** @type {?} */\n              key,\n              /** @type {?} */\n              this._options.serialize(newVal));\n            } catch (e) {\n              console.error('Error ocurred while serializing the store value, value not updated.');\n            }\n          }\n        }\n      }));\n    }\n\n  }\n\n  NgxsStoragePlugin.ɵfac = function NgxsStoragePlugin_Factory(t) {\n    return new (t || NgxsStoragePlugin)(ɵngcc0.ɵɵinject(NGXS_STORAGE_PLUGIN_OPTIONS), ɵngcc0.ɵɵinject(STORAGE_ENGINE), ɵngcc0.ɵɵinject(PLATFORM_ID));\n  };\n\n  NgxsStoragePlugin.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NgxsStoragePlugin,\n    factory: NgxsStoragePlugin.ɵfac\n  });\n  /** @nocollapse */\n\n  return NgxsStoragePlugin;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n  NgxsStoragePlugin.prototype._options;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxsStoragePlugin.prototype._engine;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxsStoragePlugin.prototype._platformId;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\n\nconst USER_OPTIONS = new InjectionToken('USER_OPTIONS');\nlet NgxsStoragePluginModule = /*#__PURE__*/(() => {\n  class NgxsStoragePluginModule {\n    /**\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\n    static forRoot(options) {\n      return {\n        ngModule: NgxsStoragePluginModule,\n        providers: [{\n          provide: NGXS_PLUGINS,\n          useClass: NgxsStoragePlugin,\n          multi: true\n        }, {\n          provide: USER_OPTIONS,\n          useValue: options\n        }, {\n          provide: NGXS_STORAGE_PLUGIN_OPTIONS,\n          useFactory: storageOptionsFactory,\n          deps: [USER_OPTIONS]\n        }, {\n          provide: STORAGE_ENGINE,\n          useFactory: engineFactory,\n          deps: [NGXS_STORAGE_PLUGIN_OPTIONS, PLATFORM_ID]\n        }]\n      };\n    }\n\n  }\n\n  NgxsStoragePluginModule.ɵfac = function NgxsStoragePluginModule_Factory(t) {\n    return new (t || NgxsStoragePluginModule)();\n  };\n\n  NgxsStoragePluginModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxsStoragePluginModule\n  });\n  NgxsStoragePluginModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return NgxsStoragePluginModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nexport { NGXS_STORAGE_PLUGIN_OPTIONS, NgxsStoragePlugin, NgxsStoragePluginModule, STORAGE_ENGINE, USER_OPTIONS as ɵa, storageOptionsFactory as ɵb, engineFactory as ɵc }; //# sourceMappingURL=ngxs-storage-plugin.js.map","map":null,"metadata":{},"sourceType":"module"}