{"ast":null,"code":"import { EventEmitter } from \"@angular/core\";\nimport { FormArray, FormControl, FormGroup } from \"@angular/forms\";\nimport { debounceTime, takeUntil } from \"rxjs/operators\";\nimport { Destroy$ } from \"../common/classes\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../services/filter.service\";\n;\n;\n;\n;\n;\nexport class AugmentedType {\n  constructor() {\n    this.cache = {};\n    this.computedProperties = {}; //maybe cache values\n  }\n\n  defineComputedProperty(name, get) {\n    this.computedProperties = Object.assign(Object.assign({}, this.computedProperties), {\n      [name]: get\n    });\n  }\n\n  getValue(item, step) {\n    const isComputedProperty = !!this.computedProperties[step.name];\n\n    if (isComputedProperty) {\n      let entry = this.cache[item.id],\n          name = step.name;\n      if (!entry) entry = this.cache[item.id] = {};\n      if (entry[name] !== void 0) return entry[name];else return entry[name] = this.computedProperties[step.name](item);\n    }\n\n    return item[step.name];\n  }\n\n}\n;\nexport let Filter = /*#__PURE__*/(() => {\n  class Filter extends Destroy$ {\n    constructor(service) {\n      super();\n      this.service = service;\n      this.input = [];\n      this.pipeline = [];\n      this.type = new AugmentedType();\n      this.updateEvent = new EventEmitter();\n    }\n\n    create(pipeline) {\n      const form = {};\n\n      for (let i = 0; i < pipeline.length; i++) {\n        const step = pipeline[i];\n\n        if (step.type != 'compute') {\n          const control = this.createControl(step);\n          form[step.type + '_' + step.name] = control;\n          this.pipeline.push(step);\n        }\n      }\n\n      const group = new FormGroup(form);\n      this.form = group;\n    }\n\n    defineComputedProperty(name, get) {\n      this.type.defineComputedProperty(name, get);\n      return {\n        type: 'compute',\n        name,\n        get\n      };\n    }\n\n    match(name) {\n      return {\n        type: 'match',\n        name\n      };\n    }\n\n    onlyIf(name, condition, otherwise, initialValue = false) {\n      return {\n        type: 'if',\n        name,\n        condition,\n        otherwise,\n        initialValue\n      };\n    }\n\n    sortBy(name, comparaison) {\n      return {\n        type: 'sort',\n        name,\n        comparaison\n      };\n    }\n\n    every(name, ...args) {\n      return {\n        name,\n        type: 'every',\n        items: args\n      };\n    }\n\n    some(name, ...args) {\n      return {\n        name,\n        type: 'some',\n        items: args\n      };\n    }\n\n    createControl(step) {\n      if (step.type == 'every' || step.type == 'some') {\n        const array = new FormArray([]);\n\n        for (const item of step.items) array.push(this.createControl(item));\n\n        return array;\n      } else {\n        if (step.type == 'if') return new FormControl(step.initialValue || false);\n        return new FormControl();\n      }\n    }\n\n    ngOnInit() {\n      this.service.add(this.name, this);\n    }\n\n    ngAfterViewInit() {\n      this.form.valueChanges.pipe(debounceTime(0), takeUntil(this.destroy$)).subscribe(() => {\n        this.update();\n      });\n    }\n\n    ngOnDestroy() {\n      this.service.remove(this.name);\n      super.ngOnDestroy();\n    }\n\n    filter(items, providers = {}) {\n      for (const key in providers) this.type.defineComputedProperty(key, providers[key]);\n\n      this.input = items;\n      return this.update();\n    }\n\n    evaluateStep(input, control, step) {\n      const controlValue = control.value;\n      let lastValue;\n\n      switch (step.type) {\n        case 'match':\n          return input.filter(item => {\n            return controlValue == this.type.getValue(item, step);\n          });\n\n        case 'if':\n          if (controlValue) {\n            const res = input.filter(item => step.condition(this.type.getValue(item, step), controlValue));\n            return res;\n          } else {\n            return step.otherwise ? step.otherwise : input;\n          }\n\n        case 'sort':\n          if (controlValue) return input.sort((item1, item2) => step.comparaison(this.type.getValue(item1, step), this.type.getValue(item2, step)));\n          break;\n\n        case 'some':\n          lastValue = new Set();\n\n          for (let i = 0; i < step.items.length; i++) lastValue = new Set([...lastValue, ...this.evaluateStep(input, control.controls[i], step.items[i])]);\n\n          return [...lastValue];\n\n        case 'every':\n          lastValue = new Set(input);\n\n          for (let i = 0; i < step.items.length; i++) {\n            const newValue = this.evaluateStep(input, control.controls[i], step.items[i]);\n            lastValue = new Set(newValue.filter(t => lastValue.has(t)));\n          }\n\n          return [...lastValue];\n\n        default:\n          break;\n      }\n\n      return input;\n    }\n\n    update() {\n      //emit and return\n      const controls = this.form.controls;\n      let input = this.input;\n      if (!input.length) return [];\n\n      for (const step of this.pipeline) {\n        const name = step.type + '_' + step.name;\n\n        if (controls[name].touched) {\n          input = this.evaluateStep(input, controls[name], step);\n        }\n      }\n\n      this.updateEvent.emit(input);\n      return input;\n    }\n\n  }\n\n  Filter.ɵfac = function Filter_Factory(t) {\n    return new (t || Filter)(i0.ɵɵdirectiveInject(i1.FilterService));\n  };\n\n  Filter.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: Filter,\n    outputs: {\n      updateEvent: \"update\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return Filter;\n})();\n;","map":null,"metadata":{},"sourceType":"module"}