{"ast":null,"code":"import produce from \"immer\";\nimport { getOriginalName } from \"./data.mapper\";\nvar mutable;\n\n(function (mutable) {\n  function addDataField(draft, target, fields) {\n    (draft.fields || (draft.fields = {}))[target] = fields;\n  }\n\n  mutable.addDataField = addDataField;\n  ;\n\n  function addValues(draft, target, values) {\n    const record = draft[target] || (draft[target] = {});\n\n    for (let key of Object.keys(values)) record[key] = values[key];\n  }\n\n  mutable.addValues = addValues;\n  ;\n\n  function deleteIds(draft, target, ids) {\n    const record = draft[target] || {},\n          currentIds = Object.keys(record).map(id => +id);\n\n    for (let id of currentIds) if (ids.includes(id)) delete record[id];\n  }\n\n  mutable.deleteIds = deleteIds;\n  ; //configure type so this can only be called on complex types\n\n  function update(draft, target, values) {\n    console.log(\"update\", target, values);\n    const targetObjects = draft[target],\n          fields = draft.fields[target]; //translate data\n\n    Object.entries(values).forEach(([id, item]) => {\n      const current = targetObjects[id]; //if not create\n\n      if (!current) {\n        for (let i = 0; i < item.length; i++) {\n          if (typeof item[i] == 'object') {\n            mutable.update(draft, fields[i], item[i]);\n            item[i] = Object.keys(item[i]).map(id => +id);\n          }\n        }\n      } else {\n        for (let i = 0; i < current.length; i++) {\n          //special treatement for arrays\n          if (Array.isArray(current[i])) {\n            if (current[i].length) mutable.deleteIds(draft, fields[i], current[i]);\n            mutable.update(draft, fields[i], item[i]);\n            item[i] = Object.keys(item[i]).map(id => +id);\n          }\n        }\n      }\n    });\n    mutable.addValues(draft, target, values);\n  }\n\n  mutable.update = update; //assumes old and rep and unique whitin themselves\n\n  function removeDuplicates(draft, target, old, rep, uniqueIndex) {\n    const objects = draft[target],\n          deletedIds = [];\n\n    newList: for (const newId of rep) {\n      for (const oldId of old) {\n        if (objects[newId][uniqueIndex] == objects[oldId][uniqueIndex]) {\n          deletedIds.push(oldId); //continue newList;\n        }\n      }\n    }\n\n    mutable.deleteIds(draft, target, deletedIds);\n    return old.filter(id => !deletedIds.includes(id));\n  } //configure to only accept simple types\n  //can create new items and add them to parent\n\n\n  function addSimpleChildren(draft, parent, parentId, child, values, uniqueBy) {\n    var _a; //Add children\n\n\n    const ids = Object.keys(values).map(id => +id); //add to parent\n\n    const parentObject = (_a = draft[parent]) === null || _a === void 0 ? void 0 : _a[parentId],\n          childIndex = draft.fields[parent].indexOf(child);\n    if (!parentObject || childIndex <= -1) return;\n    mutable.addValues(draft, child, values); //don't count overwritten ids\n\n    const oldIds = parentObject[childIndex].filter(id => !ids.includes(id));\n\n    if (uniqueBy) {\n      const uniqueIndex = draft.fields[child].indexOf(uniqueBy);\n      if (uniqueIndex !== void 0) parentObject[childIndex] = removeDuplicates(draft, child, oldIds, ids, uniqueIndex);\n    }\n\n    for (const id of ids) if (!parentObject[childIndex].includes(id)) parentObject[childIndex].push(id);\n  }\n\n  mutable.addSimpleChildren = addSimpleChildren; //configure to only accept complex data types\n  //does an update on child and supplies parent with the ids\n  //can create new items\n  //deep alternative to pushChildValues\n\n  function addComplexChildren(draft, parent, parentId, child, values, uniqueBy) {\n    var _a; //Add children\n\n\n    mutable.update(draft, child, values);\n    const ids = Object.keys(values).map(id => +id); //add to parent\n\n    const parentObject = (_a = draft[parent]) === null || _a === void 0 ? void 0 : _a[parentId],\n          childIndex = draft.fields[parent].indexOf(child);\n    if (!parentObject || childIndex <= -1) return;\n\n    for (const id of ids) if (!parentObject[childIndex].includes(id)) parentObject[childIndex].push(id);\n  }\n\n  mutable.addComplexChildren = addComplexChildren;\n\n  function replaceChildren(draft, parent, parentId, child, values) {\n    var _a;\n\n    const parentObject = (_a = draft[parent]) === null || _a === void 0 ? void 0 : _a[parentId],\n          childIndex = draft.fields[parent].indexOf(child);\n    if (!parentObject || childIndex <= -1) return;\n    mutable.deleteIds(draft, child, parentObject[childIndex]);\n    mutable.addValues(draft, child, values);\n    parentObject[childIndex] = Object.keys(values).map(id => +id);\n  }\n\n  mutable.replaceChildren = replaceChildren;\n\n  function transformField(draft, target, id, field, transform) {\n    const fields = draft.fields,\n          targetObject = draft[target][id];\n    let fieldIndex = fields[target].indexOf(getOriginalName(field));\n    if (!targetObject) return;\n    targetObject[fieldIndex] = transform(targetObject[fieldIndex], targetObject, fields);\n  }\n\n  mutable.transformField = transformField;\n})(mutable || (mutable = {}));\n\n; //use immer to makes changes immutable\n\nexport function compose(...operators) {\n  return function (existing) {\n    let output = existing;\n\n    for (const operator of operators) output = operator(output);\n\n    return output;\n  };\n}\n;\nexport function addDataField(target, fields) {\n  return produce(draft => mutable.addDataField(draft, target, fields));\n}\n;\nexport function deleteIds(target, ids) {\n  return produce(draft => mutable.deleteIds(draft, target, ids));\n}\n;\nexport function addValues(target, values) {\n  return produce(draft => mutable.addValues(draft, target, values));\n}\n;\nexport function addRecord(target, fields, values) {\n  return compose(addDataField(target, fields), addValues(target, values));\n}\n;\nexport function update(target, values) {\n  return produce(draft => mutable.update(draft, target, values));\n}\n;\nexport function addSimpleChildren(parent, parentId, child, values, uniqueBy) {\n  return produce(draft => mutable.addSimpleChildren(draft, parent, parentId, child, values, uniqueBy));\n}\n;\nexport function addComplexChildren(parent, parentId, child, values) {\n  return produce(draft => mutable.addComplexChildren(draft, parent, parentId, child, values));\n}\n;\nexport function transformField(target, id, field, transform) {\n  return produce(draft => mutable.transformField(draft, target, id, field, transform));\n}\n;\nexport function replaceChildren(parent, parentId, child, values) {\n  return produce(draft => mutable.replaceChildren(draft, parent, parentId, child, values));\n}\n;","map":null,"metadata":{},"sourceType":"module"}