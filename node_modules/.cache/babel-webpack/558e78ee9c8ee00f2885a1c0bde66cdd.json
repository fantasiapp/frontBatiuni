{"ast":null,"code":"var DataState_1;\nimport { __decorate, __rest } from \"tslib\";\nimport { Action, createSelector, Selector, State } from \"@ngxs/store\";\nimport { Observable, of, Subject } from \"rxjs\";\nimport { concatMap, map, tap } from \"rxjs/operators\";\nimport { GetGeneralData, HandleApplication, SignContract, MarkViewed, ModifyAvailability, SetFavorite, TakePicture } from \"./user/user.actions\";\nimport { ApplyPost, ChangePassword, ChangeProfilePicture, ChangeProfileType, DeleteFile, DeletePost, DownloadFile, DuplicatePost, GetUserData, ModifyUserProfile, CreateDetailedPost, ModifyDetailedPost, CreateSupervision, SwitchPostType, UploadFile, UploadPost, UploadImageSupervision } from \"./user/user.actions\";\nimport { NameMapping } from \"./data.mapper\";\nimport { addValues, compose, deleteIds, addSimpleChildren, transformField, addComplexChildren, replaceChildren } from \"./state.operators\";\nimport { Logout } from \"../auth/auth.actions\";\nimport { GetCompanies } from \"./search/search.actions\";\nimport produce from \"immer\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngxs/store\";\nimport * as i2 from \"./data.mapper\";\nimport * as i3 from \"src/app/services/http.service\";\nimport * as i4 from \"src/app/shared/components/info/info.component\";\nimport * as i5 from \"src/app/shared/components/slidemenu/slidemenu.component\";\nimport * as i6 from \"src/app/shared/components/swipeup/swipeup.component\";\n;\nexport let Clear = /*#__PURE__*/(() => {\n  class Clear {\n    constructor(data) {\n      this.data = data;\n    }\n\n  }\n\n  Clear.type = '[Data] Clear';\n  return Clear;\n})();\n;\nlet DataState = DataState_1 = class DataState {\n  constructor(store, reader, http, info, slide, swipeup, zone) {\n    this.store = store;\n    this.reader = reader;\n    this.http = http;\n    this.info = info;\n    this.slide = slide;\n    this.swipeup = swipeup;\n    this.zone = zone;\n    this.pending$ = {};\n  }\n\n  registerPending(key, pending) {\n    this.pending$[key] = pending;\n    return key;\n  }\n\n  getPending(key) {\n    return this.pending$[key];\n  }\n\n  completePending(key) {\n    const pending = this.getPending(key);\n\n    if (pending) {\n      pending.complete();\n      delete this.pending$[key];\n    }\n  }\n\n  inZone(f) {\n    this.zone.run(() => f());\n  }\n\n  clear(ctx, clear) {\n    const current = ctx.getState();\n    if (clear.data) ctx.patchState({\n      [clear.data]: {},\n      fields: Object.assign(Object.assign({}, current.fields), {\n        [clear.data]: []\n      })\n    });else ctx.setState({\n      fields: {},\n      session: {\n        currentUser: -1,\n        view: 'ST'\n      }\n    });\n  }\n\n  static fields(state) {\n    return state.fields;\n  } //try to avoid container state in the future\n\n\n  static currentUserId(state) {\n    return state.session.currentUser;\n  }\n\n  static view(state) {\n    return state.session.view;\n  }\n\n  static companies(state) {\n    return state['Company'] || {};\n  }\n\n  static users(state) {\n    return state['UserProfile'] || {};\n  }\n\n  static files(state) {\n    return state['File'] || {};\n  }\n\n  static posts(state) {\n    return state['Post'] || {};\n  }\n\n  static missions(state) {\n    return state['Mission'] || {};\n  }\n\n  static getType(type) {\n    return createSelector([DataState_1], state => {\n      return state[type] || {};\n    });\n  }\n\n  //------------------------------------------------------------------------\n  getGeneralData(ctx) {\n    //eventually make a local storage service\n    //const data = localStorage.getItem('general-data');\n    const req =\n    /*data ? of(JSON.parse(data)) : */\n    this.http.get('initialize', {\n      action: 'getGeneralData'\n    });\n    return req.pipe(tap(response => {\n      //localStorage.setItem('general-data', JSON.stringify(response));\n      const operations = this.reader.readStaticData(response);\n      ctx.setState(compose(...operations));\n    }));\n  }\n\n  getUserData(ctx, action) {\n    const req = this.http.get('data', {\n      action: action.action\n    });\n    return req.pipe(tap(response => {\n      console.log('$$', response);\n      const loadOperations = this.reader.readInitialData(response),\n            sessionOperation = this.reader.readCurrentSession(response);\n      ctx.setState(compose(...loadOperations, sessionOperation));\n      console.log(ctx.getState());\n    }));\n  }\n\n  logout(ctx) {\n    ctx.setState({\n      fields: {},\n      session: {\n        view: 'ST',\n        currentUser: -1\n      }\n    });\n    ctx.dispatch(new GetGeneralData()); // a sign to decouple this from DataModel\n  }\n\n  modifyUser(ctx, modify) {\n    const {\n      labelFiles,\n      adminFiles,\n      onlyFiles\n    } = modify,\n          modifyAction = __rest(modify, [\"labelFiles\", \"adminFiles\", \"onlyFiles\"]);\n\n    let req;\n    if (onlyFiles) req = of({\n      [modify.action]: 'OK'\n    });else req = this.http.post('data', modifyAction);\n    return req.pipe(tap(response => {\n      if (response[modify.action] !== 'OK') throw response['messages'];\n      delete response[modify.action];\n      ctx.setState(compose(...this.reader.readUpdates(response)));\n    }), concatMap(() => {\n      labelFiles.forEach(file => ctx.dispatch(new UploadFile(file, 'labels', file.nature, 'Company')));\n      Object.keys(adminFiles).forEach(name => ctx.dispatch(new UploadFile(adminFiles[name], 'admin', name, 'Company')));\n      return of(true);\n    }));\n  }\n\n  changeProfilePicture(ctx, picture) {\n    const profile = this.store.selectSnapshot(DataQueries.currentProfile),\n          image = this.store.selectSnapshot(DataQueries.getProfileImage(profile.company.id)),\n          req = this.http.post('data', picture);\n    return req.pipe(tap(response => {\n      if (response[picture.action] !== 'OK') throw response['messages'];\n      delete response[picture.action];\n      ctx.setState(compose(addSimpleChildren('Company', profile.company.id, 'File', response, 'nature')));\n    }));\n  }\n\n  uploadImageSupervision(ctx, picture) {\n    const profile = this.store.selectSnapshot(DataQueries.currentProfile),\n          req = this.http.post('data', picture);\n    console.log(\"UploadImageSupervision\", picture);\n    return req.pipe(tap(response => {\n      console.log(\"UploadImageSupervision response\", response);\n      if (response[picture.action] !== 'OK') throw response['messages'];\n      delete response[picture.action]; // ctx.setState(compose(\n      //   addSimpleChildren('Company', profile.company.id, 'File', response, 'nature'),\n      // ));\n    }));\n  }\n\n  modifyPassword(ctx, action) {\n    return this.http.post('data', action).pipe(tap(response => {\n      if (response[action.action] != 'OK') throw response['messages'];\n    }));\n  }\n\n  changeProfileType(ctx, action) {\n    const state = ctx.getState();\n    return ctx.patchState({\n      session: Object.assign(Object.assign({}, state.session), {\n        view: action.type ? 'PME' : 'ST'\n      })\n    });\n  }\n\n  uploadFile(ctx, upload) {\n    console.log(\"uploadFile\", upload);\n    const req = this.http.post('data', upload);\n    return req.pipe(tap(response => {\n      if (response[upload.action] !== 'OK') throw response['messages'];\n      delete response[upload.action];\n      const assignedId = +Object.keys(response)[0],\n            fields = ctx.getState()['fields'],\n            contentIndex = fields['File'].indexOf('content');\n      upload.assignedId = assignedId;\n      response[assignedId][contentIndex] = upload.fileBase64;\n\n      if (upload.category == 'Company') {\n        //add it to company\n        const company = this.store.selectSnapshot(DataQueries.currentCompany);\n        ctx.setState(addSimpleChildren('Company', company.id, 'File', response, 'name'));\n      } else if (upload.category == 'Post') {\n        ctx.setState(addSimpleChildren('Post', upload.target, 'File', response, 'name'));\n      }\n    }));\n  }\n\n  takePicture(ctx, picture) {// console.log(\"uploadFile\", picture)\n    // return this.http.post('data', picture).pipe(\n    //   tap((response: any) => {\n    //     if ( response[picture.action] !== 'OK' )\n    //       throw response['messages']\n    //     delete response[picture.action]\n    //     const assignedId = +Object.keys(response)[0],\n    //       fields = ctx.getState()['fields'],\n    //       contentIndex = fields['File'].indexOf('content');\n    //     picture.assignedId = assignedId;\n    //     response[assignedId][contentIndex] = upload.fileBase64;\n  }\n\n  deleteFile(ctx, deletion) {\n    const req = this.http.get('data', deletion);\n    return req.pipe(tap(response => {\n      if (response[deletion.action] !== 'OK') throw response['messages'];\n      delete response[deletion.action];\n      ctx.setState(deleteIds('File', [deletion.id]));\n    }));\n  }\n\n  createPost(ctx, post) {\n    const profile = this.store.selectSnapshot(DataQueries.currentProfile),\n          {\n      files\n    } = post,\n          form = __rest(post, [\"files\"]),\n          uploads = Object.keys(files).map(key => new UploadFile(files[key], 'post', key, 'Post')),\n          req = this.http.post('data', form);\n\n    return req.pipe(map(response => {\n      if (response[post.action] !== 'OK') throw response['messages'];\n      delete response[post.action]; //add post, return its id\n\n      const assignedId = +Object.keys(response)[0];\n      ctx.setState(addComplexChildren('Company', profile.company.id, 'Post', response));\n      return assignedId;\n    }), concatMap(postId => {\n      uploads.forEach(upload => upload.target = postId);\n      console.log('now uploads are', uploads); //return this to wait for file downloads first\n\n      return ctx.dispatch(uploads);\n    }));\n  }\n\n  switchPostType(ctx, switchType) {\n    return this.http.get('data', switchType).pipe(tap(response => {\n      if (response[switchType.action] !== 'OK') throw response['messages'];\n      delete response[switchType.action];\n      ctx.setState(transformField('Post', switchType.id, 'draft', draft => !draft));\n    }));\n  }\n\n  deletePost(ctx, deletion) {\n    return this.http.get('data', deletion).pipe(tap(response => {\n      if (response[deletion.action] !== 'OK') throw response['messages'];\n      delete response[deletion.action];\n      ctx.setState(deleteIds('Post', [deletion.id]));\n    }));\n  }\n\n  duplicatePost(ctx, duplicate) {\n    return this.http.get('data', duplicate).pipe(tap(response => {\n      if (response[duplicate.action] !== 'OK') throw response[duplicate.action];\n      delete response[duplicate.action];\n      ctx.setState(addValues('Post', response));\n    }));\n  }\n\n  downloadFile(ctx, download) {\n    const state = ctx.getState(),\n          nameIndex = state.fields['File'].indexOf('name'),\n          contentIndex = state.fields['File'].indexOf('content'),\n          key = `file_${download.id}`,\n          file = ctx.getState()['File'][download.id]; //check if the file is already downloaded\n\n    if (file && file[contentIndex]) {\n      return file.content;\n    } //check if we are currently downloading the file\n\n\n    let pending = this.getPending(key);\n    if (pending) return pending; //download the file and register that we downloading;\n\n    let req = this.http.get('data', download);\n    pending = new Subject();\n    this.registerPending(key, pending);\n    if (download.notify) console.log(`Téléchargement du fichier ${file[nameIndex] || ''}...`);\n    this.inZone(() => {\n      this.info.show(\"info\", `Téléchargement du fichier ${file[nameIndex] || ''}...`);\n    });\n    return req.pipe(tap(response => {\n      if (response[download.action] !== 'OK') {\n        if (download.notify) this.inZone(() => this.info.show('error', response['messages'], 5000));\n        throw response['messages'];\n      }\n\n      delete response[download.action];\n      if (download.notify) this.inZone(() => this.info.show('success', `Fichier ${file[nameIndex]} téléchargé.`, 1000)); //overwrite\n\n      ctx.setState(addValues('File', response)); //file is now downloaded\n\n      pending.next(response[contentIndex]);\n      this.completePending(key);\n    }));\n  }\n\n  applyPost(ctx, application) {\n    //{Post: 1, amount: 500, devis: 'Par heure', action: 'applyPost'}\n    return this.http.get('data', application).pipe(tap(response => {\n      if (response[application.action] != 'OK') throw response['messages'];\n      delete response[application.action];\n      ctx.setState(addValues('Candidate', response));\n    }));\n  }\n\n  modifyAvailability(ctx, availability) {\n    return this.http.post('data', availability).pipe(tap(response => {\n      if (response[availability.action] != 'OK') throw response['messages'];\n      delete response[availability.action];\n      const company = this.store.selectSnapshot(DataQueries.currentCompany);\n      ctx.setState( //doest work because it leaves old values\n      //pushChildValues('Company', company.id, 'Disponibility', response, 'date')\n      compose(replaceChildren('Company', company.id, 'Disponibility', response)));\n    }));\n  }\n\n  handleApplication(ctx, handle) {\n    const {\n      post\n    } = handle,\n          data = __rest(handle, [\"post\"]);\n\n    return this.http.get('data', data).pipe(tap(response => {\n      if (response[handle.action] !== 'OK') {\n        this.inZone(() => this.info.show(\"error\", response.messages, 3000));\n        throw response.messages;\n      }\n\n      delete response[handle.action];\n      const company = this.store.selectSnapshot(DataQueries.currentCompany);\n      this.inZone(() => this.info.show(\"success\", \"Réponse envoyée.\", 3000));\n      this.slide.hide();\n      ctx.setState(compose(deleteIds('Post', [handle.post.id]), addComplexChildren('Company', company.id, 'Mission', response)));\n    }));\n  }\n\n  signContract(ctx, application) {\n    const profile = this.store.selectSnapshot(DataQueries.currentProfile);\n    return this.http.get('data', application).pipe(tap(response => {\n      if (response[application.action] !== 'OK') {\n        this.inZone(() => this.info.show(\"error\", response.messages, 3000));\n        throw response.messages;\n      }\n\n      delete response[application.action];\n      ctx.setState(addComplexChildren('Company', profile.company.id, 'Mission', response));\n    }));\n  }\n\n  createDetailedPost(ctx, application) {\n    const profile = this.store.selectSnapshot(DataQueries.currentProfile);\n    return this.http.post('data', application).pipe(tap(response => {\n      if (response[application.action] !== 'OK') {\n        this.inZone(() => this.info.show(\"error\", response.messages, 3000));\n        throw response.messages;\n      }\n\n      delete response[application.action];\n      ctx.setState(addComplexChildren('Company', profile.company.id, 'Mission', response));\n    }));\n  }\n\n  modifyDetailedPost(ctx, application) {\n    const profile = this.store.selectSnapshot(DataQueries.currentProfile);\n    return this.http.post('data', application).pipe(tap(response => {\n      if (response[application.action] !== 'OK') {\n        this.inZone(() => this.info.show(\"error\", response.messages, 3000));\n        throw response.messages;\n      }\n\n      delete response[application.action];\n      ctx.setState(addComplexChildren('Company', profile.company.id, 'Mission', response));\n    }));\n  }\n\n  createSupervision(ctx, application) {\n    const profile = this.store.selectSnapshot(DataQueries.currentProfile);\n    return this.http.post('data', application).pipe(tap(response => {\n      if (response[application.action] !== 'OK') {\n        this.inZone(() => this.info.show(\"error\", response.messages, 3000));\n        throw response.messages;\n      }\n\n      delete response[application.action];\n      ctx.setState(addComplexChildren('Company', profile.company.id, 'Mission', response));\n    }));\n  } //------------------------------------------------------------------\n  // For temporary actions\n\n\n  getCompanies(ctx, get) {\n    return this.http.get('initialize', get).pipe(tap(response => {\n      ctx.setState(compose(this.reader.readInitialData(response)[0], //very error prone\n      //i really hate doing this\n      produce(draft => {\n        draft.fields['Establishments'] = ['name', 'address', 'activity', 'siret', 'ntva'];\n        return draft;\n      })));\n    }));\n  }\n\n  setFavorite(ctx, favorite) {\n    const id = this.store.selectSnapshot(DataState_1.currentUserId);\n    return this.http.get('data', favorite).pipe(tap(response => {\n      if (response[favorite.action] !== 'OK') this.inZone(() => this.info.show(\"error\", response.messages, 3000));\n      ctx.setState(transformField('UserProfile', id, 'favoritePosts', favorites => {\n        if (favorite.value) return [...favorites, favorite.Post];else return favorites.filter(id => favorite.Post !== id);\n      }));\n      this.inZone(() => this.info.show(\"success\", favorite.value ? 'Annonce ajoutée au favoris.' : 'Annonce retirée des favoris', 1000));\n    }));\n  }\n\n  markViewed(ctx, view) {\n    const user = this.store.selectSnapshot(DataQueries.currentUser);\n    if (user.viewedPosts.includes(view.Post)) return;\n    return this.http.get('data', view).pipe(tap(response => {\n      ctx.setState(transformField('UserProfile', user.id, 'viewedPosts', viewed => {\n        return [...viewed, view.Post];\n      }));\n    }));\n  }\n\n};\n\nDataState.ɵfac = function DataState_Factory(t) {\n  return new (t || DataState)(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i2.DataReader), i0.ɵɵinject(i3.HttpService), i0.ɵɵinject(i4.InfoService), i0.ɵɵinject(i5.SlidemenuService), i0.ɵɵinject(i6.SwipeupService), i0.ɵɵinject(i0.NgZone));\n};\n\nDataState.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: DataState,\n  factory: DataState.ɵfac\n});\n\n__decorate([Action(Clear)], DataState.prototype, \"clear\", null);\n\n__decorate([Action(GetGeneralData)], DataState.prototype, \"getGeneralData\", null);\n\n__decorate([Action(GetUserData)], DataState.prototype, \"getUserData\", null);\n\n__decorate([Action(Logout)], DataState.prototype, \"logout\", null);\n\n__decorate([Action(ModifyUserProfile)], DataState.prototype, \"modifyUser\", null);\n\n__decorate([Action(ChangeProfilePicture)], DataState.prototype, \"changeProfilePicture\", null);\n\n__decorate([Action(UploadImageSupervision)], DataState.prototype, \"uploadImageSupervision\", null);\n\n__decorate([Action(ChangePassword)], DataState.prototype, \"modifyPassword\", null);\n\n__decorate([Action(ChangeProfileType)], DataState.prototype, \"changeProfileType\", null);\n\n__decorate([Action(UploadFile)], DataState.prototype, \"uploadFile\", null);\n\n__decorate([Action(TakePicture)], DataState.prototype, \"takePicture\", null);\n\n__decorate([Action(DeleteFile)], DataState.prototype, \"deleteFile\", null);\n\n__decorate([Action(UploadPost)], DataState.prototype, \"createPost\", null);\n\n__decorate([Action(SwitchPostType)], DataState.prototype, \"switchPostType\", null);\n\n__decorate([Action(DeletePost)], DataState.prototype, \"deletePost\", null);\n\n__decorate([Action(DuplicatePost)], DataState.prototype, \"duplicatePost\", null);\n\n__decorate([Action(DownloadFile)], DataState.prototype, \"downloadFile\", null);\n\n__decorate([Action(ApplyPost)], DataState.prototype, \"applyPost\", null);\n\n__decorate([Action(ModifyAvailability)], DataState.prototype, \"modifyAvailability\", null);\n\n__decorate([Action(HandleApplication)], DataState.prototype, \"handleApplication\", null);\n\n__decorate([Action(SignContract)], DataState.prototype, \"signContract\", null);\n\n__decorate([Action(CreateDetailedPost)], DataState.prototype, \"createDetailedPost\", null);\n\n__decorate([Action(ModifyDetailedPost)], DataState.prototype, \"modifyDetailedPost\", null);\n\n__decorate([Action(CreateSupervision)], DataState.prototype, \"createSupervision\", null);\n\n__decorate([Action(GetCompanies)], DataState.prototype, \"getCompanies\", null);\n\n__decorate([Action(SetFavorite)], DataState.prototype, \"setFavorite\", null);\n\n__decorate([Action(MarkViewed)], DataState.prototype, \"markViewed\", null);\n\n__decorate([Selector()], DataState, \"fields\", null);\n\n__decorate([Selector()], DataState, \"currentUserId\", null);\n\n__decorate([Selector()], DataState, \"view\", null);\n\n__decorate([Selector([DataState_1])], DataState, \"companies\", null);\n\n__decorate([Selector([DataState_1])], DataState, \"users\", null);\n\n__decorate([Selector([DataState_1])], DataState, \"files\", null);\n\n__decorate([Selector([DataState_1])], DataState, \"posts\", null);\n\n__decorate([Selector([DataState_1])], DataState, \"missions\", null);\n\nDataState = DataState_1 = __decorate([State({\n  name: 'd',\n  defaults: {\n    fields: {},\n    session: {\n      currentUser: -1,\n      view: 'ST'\n    }\n  }\n})], DataState);\nexport { DataState };\n; //make a deep version of toJSON\n\nexport class DataQueries {\n  static toJson(allFields, target, id, values) {\n    const fields = allFields[target];\n    const output = {};\n\n    if (Array.isArray(values)) {\n      if (fields.length != values.length) throw `Value is probably not of type ${target}`;\n\n      for (let i = 0; i < values.length; i++) {\n        const name = fields[i],\n              jsonName = NameMapping[name] || name;\n        output[jsonName] = values[i];\n      }\n    } else {\n      output.name = values;\n    }\n\n    output.id = id;\n    return output;\n  } //think about optimizing selectors\n  //maybe already set injectContainerState to false\n  //each of these have seperate memoization\n\n\n  static currentUser(profiles, fields, id) {\n    console.log('current user change');\n    return DataQueries.toJson(fields, \"UserProfile\", id, profiles[id]);\n  }\n\n  static currentCompany(companies, fields, id) {\n    console.log('company change');\n    return DataQueries.toJson(fields, \"Company\", id, companies[id]);\n  }\n\n  static currentProfile(user, company) {\n    return {\n      user,\n      company\n    };\n  }\n\n  static getDataById(type, id) {\n    return createSelector([DataState.getType(type)], record => {\n      return record[id];\n    });\n  } // a profile is a company\n\n\n  static getProfileById(id) {\n    return createSelector([DataState.fields, DataState.companies], (fields, companies) => {\n      const company = companies[id];\n      if (!company) return null;\n      return {\n        user: null,\n        company: DataQueries.toJson(fields, 'Company', id, companies[id])\n      };\n    });\n  }\n\n  static getProfileByUserId(id) {\n    return createSelector([DataState.fields, DataState.users, DataState.companies], (fields, users, companies) => {\n      const companyIndex = fields['UserProfile'].indexOf('Company'),\n            user = users[id],\n            companyId = user === null || user === void 0 ? void 0 : user[companyIndex];\n      if (!user || companyId == undefined) return null;\n      return {\n        user: DataQueries.toJson(fields, 'UserProfile', id, users[id]),\n        company: DataQueries.toJson(fields, 'Company', companyId, companies[companyId])\n      };\n    });\n  }\n\n  static getById(type, id) {\n    //no id => get All\n    return createSelector([DataState.fields, DataQueries.getDataById(type, id)], (fields, values) => {\n      return values ? DataQueries.toJson(fields, type, id, values) : null;\n    });\n  }\n\n  static getMany(type, ids) {\n    return createSelector([DataState.fields, DataState.getType(type)], (fields, record) => {\n      return ids.map(id => {\n        const values = record[id];\n        return DataQueries.toJson(fields, type, +id, values);\n      });\n    });\n  }\n\n  static getAll(type) {\n    //no id => get All\n    return createSelector([DataState.fields, DataState.getType(type)], (fields, record) => {\n      return Object.keys(record).map(id => {\n        const values = record[id];\n        return DataQueries.toJson(fields, type, +id, values);\n      });\n    });\n  }\n\n  static contentOf(parent, parentId, child) {\n    return createSelector([DataState.fields, DataState.getType(child), DataQueries.getDataById(parent, parentId)], (fields, childItems, parentItem) => {\n      const index = fields[parent].indexOf(child);\n      if (index <= 0) throw `${child} is not a child of ${parent}.`;\n      return parentItem[index].map(id => childItems[id]);\n    });\n  }\n\n  static getProfileImage(id) {\n    return createSelector([DataState.fields, DataQueries.getDataById('Company', id), DataState.files], (fields, company, files) => {\n      const filesIndex = fields['Company'].indexOf('File'),\n            natureIndex = fields['File'].indexOf('nature'),\n            fileIds = (company === null || company === void 0 ? void 0 : company[filesIndex]) || [];\n\n      for (let id of fileIds) if (files[id][natureIndex] == 'userImage') return DataQueries.toJson(fields, 'File', id, files[id]);\n\n      return null;\n    });\n  }\n\n}\n\n__decorate([Selector([DataState.users, DataState.fields, DataState.currentUserId])], DataQueries, \"currentUser\", null);\n\n__decorate([Selector([DataState.companies, DataState.fields, DataState.currentUserId])], DataQueries, \"currentCompany\", null);\n\n__decorate([Selector([DataQueries.currentUser, DataQueries.currentCompany])], DataQueries, \"currentProfile\", null);\n\n; //type ChildOf<K extends DataTypes> = keyof Interface<K>;\n//type ChildSequence<A extends DataTypes, B extends ChildOf<A>> = ChildOf<B>;\n//Decorator\n//Assumes object has store\n//if an object or an observable is given, it won't query\n//One thing that can be improved is how we deal with observable\n//If component depend on the observable to retrieve the value, they kinda\n//have to manage subscripton on their own\n//a better way would be to memoize the value and use switchMap inside the setter\n\nexport function Query(type) {\n  return function (target, key) {\n    const hiddenKey = '#' + key;\n    Object.defineProperty(target, key, {\n      get() {\n        return this[hiddenKey] ? this[hiddenKey].value : new Observable(subscriber => {\n          subscriber.next(null);\n          subscriber.complete();\n        });\n      },\n\n      set(id) {\n        if (this[hiddenKey] && (this[hiddenKey].id === id || this[hiddenKey].value === id)) return;\n\n        if (typeof id == 'number') {\n          this[hiddenKey] = {\n            id,\n            value: this.store.select(DataQueries.getById(type, id)) //what about unsubscribe\n\n          };\n        } else if (id instanceof Observable) {\n          this[hiddenKey] = {\n            id: undefined,\n            value: id\n          };\n        } else {\n          this[hiddenKey] = {\n            id: id.id,\n            value: of(id)\n          };\n        }\n      },\n\n      enumerable: false,\n      configurable: false\n    });\n  };\n}\n; //Same as Query but returns a snapshot\n\nexport function Snapshot(type) {\n  return function (target, key) {\n    const hiddenKey = '#' + key;\n    Object.defineProperty(target, key, {\n      get() {\n        return this[hiddenKey] ? this[hiddenKey].value : null;\n      },\n\n      set(id) {\n        if (this[hiddenKey] && (this[hiddenKey].id === id || this[hiddenKey].value === id)) return; //id\n\n        if (typeof id == 'number') {\n          this[hiddenKey] = {\n            id,\n            value: this.store.selectSnapshot(DataQueries.getById(type, id))\n          };\n        } else {\n          this[hiddenKey] = {\n            id: id.id,\n            value: id\n          };\n        }\n      },\n\n      enumerable: false,\n      configurable: false\n    });\n  };\n}\n;\nexport function QueryAll(type) {\n  return function (target, key) {\n    const hiddenKey = '#' + key;\n    Object.defineProperty(target, key, {\n      get() {\n        if (!this[hiddenKey]) this[hiddenKey] = this.store.select(DataQueries.getAll(type));\n        return this[hiddenKey];\n      },\n\n      enumerable: false,\n      configurable: false\n    });\n  };\n}\n;\nexport function SnapshotAll(type) {\n  return function (target, key) {\n    const hiddenKey = '#' + key;\n    Object.defineProperty(target, key, {\n      get() {\n        if (!this[hiddenKey]) this[hiddenKey] = this.store.selectSnapshot(DataQueries.getAll(type));\n        return this[hiddenKey];\n      },\n\n      enumerable: false,\n      configurable: false\n    });\n  };\n}\n;\nexport function QueryArray(type) {\n  return function (target, key) {\n    const hiddenKey = '#' + key;\n    Object.defineProperty(target, key, {\n      get() {\n        return this[hiddenKey] ? this[hiddenKey] : [];\n      },\n\n      set(ids) {\n        this[hiddenKey] = this.store.select(DataQueries.getMany(type, ids));\n      },\n\n      enumerable: false,\n      configurable: false\n    });\n  };\n}\n;\nexport function SnapshotArray(type) {\n  return function (target, key) {\n    const hiddenKey = '#' + key;\n    Object.defineProperty(target, key, {\n      get() {\n        return this[hiddenKey] ? this[hiddenKey] : [];\n      },\n\n      set(ids) {\n        this[hiddenKey] = this.store.selectSnapshot(DataQueries.getMany(type, ids));\n      },\n\n      enumerable: false,\n      configurable: false\n    });\n  };\n}\nexport function QueryProfile(config = {\n  byUserId: false\n}) {\n  return function (target, key) {\n    const hiddenKey = '#' + key;\n    Object.defineProperty(target, key, {\n      get() {\n        return this[hiddenKey] ? this[hiddenKey].value : new Observable(subscriber => {\n          subscriber.next(null);\n          subscriber.complete();\n          subscriber.unsubscribe();\n        });\n      },\n\n      set(id) {\n        if (this[hiddenKey] && (this[hiddenKey].id === id || this[hiddenKey].value === id)) return;\n\n        if (typeof id == 'number') {\n          this[hiddenKey] = {\n            id,\n            value: this.store.select(config.byUserId ? DataQueries.getProfileByUserId(id) : DataQueries.getProfileById(id))\n          };\n        } else if (id instanceof Observable) {\n          this[hiddenKey] = {\n            id: undefined,\n            value: id\n          };\n        } else {\n          //this is wasteful because it can set multiple times\n          //but apparently fires as many\n          this[hiddenKey] = {\n            id: id.id,\n            value: of(id)\n          }; //but this doesn't work :(\n          // this[hiddenKey] = { id: id.id, value: id }\n        }\n      },\n\n      enumerable: false,\n      configurable: false\n    });\n  };\n}\n;","map":null,"metadata":{},"sourceType":"module"}